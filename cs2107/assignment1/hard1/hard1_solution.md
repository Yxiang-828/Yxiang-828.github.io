# CS2107 Assignment 1 Hard1 Solution

## Problem Analysis

The challenge requires predicting the MD5 hash of a random number generated by the server. The server:

1. Gets current time with `time(&raw)`
2. Prints the time using `asctime(localtime(&raw))`
3. Seeds the random number generator with `srand(time(NULL))`
4. Generates a random number with `rand()`
5. Creates an MD5 hash of the random number (as string)
6. Waits for user input of the hash

The key insight is that `rand()` is a pseudorandom number generator that produces deterministic output when seeded with the same value. The challenge is to predict what `rand()` will output given the printed timestamp.

## Challenges Faced

### 1. Architecture and Library Differences
- `rand()` implementation varies between Windows (MSVC) and Linux (glibc)
- Different CPU architectures (x86_64 vs ARM) may have different implementations
- The assignment specifically requires Intel x86_64 architecture and SSH to NUS servers

### 2. Timing Issues
- The server calls `time(&raw)` and `time(NULL)` at slightly different times
- Network latency between getting the time string and submitting the hash
- Server generates a new challenge for each connection

### 3. Timezone Confusion
- Server prints time in its local timezone (UTC in this case)
- Solver initially used `mktime()` which assumes local time, causing 8-hour offset
- NUS servers are in Singapore timezone (UTC+8), challenge server appears to be in UTC

### 4. Parsing Issues
- `asctime()` output format: "Sat Sep 13 17:47:24 2025\n"
- Need to parse this back to Unix timestamp for seeding
- Different parsing functions (`mktime` vs `timegm`) handle timezones differently

## Solution Approach

### Step 1: Understanding the Server Code
From `chall.c`:
```c
time_t raw;
time(&raw);
printf("%s\n", asctime(localtime(&raw)));  // Prints local time
srand(time(NULL));                         // Seeds with UTC timestamp
int random = rand();
char key[...];
sprintf(key, "%d", random);                // Convert to string
md5String(key, result);                    // MD5 hash
```

The server prints local time but seeds with UTC time.

### Step 2: Creating the Solver
- Parse the printed time string as UTC (since server is in UTC)
- Use `timegm()` instead of `mktime()` to avoid local timezone conversion
- Simulate `srand(seed); rand()` with the parsed timestamp
- Compute MD5 of the random number string

### Step 3: Handling Timing
- Get fresh time string from server
- Immediately compute hash on same architecture (NUS Linux x86_64)
- Submit hash to same server connection to avoid new challenge generation

## Implementation Details

### Time Parsing
```c
struct tm tm;
memset(&tm, 0, sizeof(struct tm));
// Parse "Sat Sep 13 17:47:24 2025"
sscanf(time_str, "%*s %s %d %d:%d:%d %d", mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &tm.tm_year);
tm.tm_year -= 1900;
tm.tm_mon = month_to_int(mon);
tm.tm_isdst = -1;

time_t t = timegm(&tm);  // Parse as UTC
```

### Random Number Simulation
```c
srand(t);
int random = rand();
```

### MD5 Computation
```c
char key[...];
sprintf(key, "%d", random);
md5String(key, result);
// Convert to hex string
for(int i = 0; i < 16; ++i)
    sprintf(&md5string[i*2], "%02x", (unsigned int)result[i]);
```

## Execution Steps

1. **Get Time String:**
   ```bash
   ncat cs2107-ctfd-i.comp.nus.edu.sg 5001
   ```
   Output: "Sat Sep 13 17:47:24 2025"

2. **Compute Hash on NUS Server:**
   ```bash
   ./solver "Sat Sep 13 17:47:24 2025"
   ```
   Output: MD5 hash

3. **Submit Hash:**
   Paste the hash to the same ncat session

## Key Fixes Applied

1. **Timezone Fix:** Changed `mktime()` to `timegm()` to parse time string as UTC
2. **Architecture Match:** Ran solver on Intel x86_64 Linux (NUS servers)
3. **Timing Fix:** Used same connection for time retrieval and hash submission
4. **Library Match:** Used glibc `rand()` implementation matching the server

## Files Used

- `solver.c` - Main solver program
- `md5.c` - MD5 implementation
- `md5.h` - MD5 header
- `chall.c` - Server code (for analysis)

## Flag Obtained

CS2107{p53ud0_r4nd0m_15_n0t_7ru3_r4nd0m!!}

This confirms that pseudorandom number generators are deterministic and predictable when seeded with known values.</content>
<parameter name="filePath">c:\Users\xiang\Desktop\y2\cs2107\assignment1\hard1\hard1_solution.md