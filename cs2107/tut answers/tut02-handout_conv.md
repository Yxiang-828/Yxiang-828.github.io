# CS2107 â€” Introduction to Information Security

## Page 1

CS2107 â€” Introduction to Information Security
AY2025/2026 Semester 1
Tutorial 2
Shen Jiamin
Question 1
You have intercepted two ciphertexts ğ¶1, ğ¶2 generated by a stream cipher using the same
secret key. The first 4 bits of the ciphertext form the IV.
ğ¶1 = 0111 11011011
ğ¶2 = 0111 00101011
You know that the plaintext must be among the following 4 sequences:
ğ‘ƒ1 = 00000000, ğ‘ƒ2 = 11111111, ğ‘ƒ3 = 00001111, ğ‘ƒ4 = 11000011
What are the possible plaintexts of ğ¶1 and ğ¶2?
Answer
The important observation here is that the same IV is used for both ciphertexts,
which allows us to exploit the properties of the XOR operation.
Stream ciphers encrypt plaintext by XORing it with a keystream generated from the secret key
and IV, i.e.
ğ¶= ğ‘ƒâŠ•PRG(ğ¾, ğ¼ğ‘‰).
Since the same IV is used, the keystream for both ciphertexts is identical. Thus
ğ¶1 âŠ•ğ¶2 = (ğ‘ƒ1 âŠ•PRG(ğ¾, ğ¼ğ‘‰)) âŠ•(ğ‘ƒ2 âŠ•PRG(ğ¾, ğ¼ğ‘‰)) = ğ‘ƒ1 âŠ•ğ‘ƒ2 = 11110000.
ğ¶1 âŠ•ğ¶1 = 11110000.
âŠ•
ğ‘ƒ1
ğ‘ƒ2
ğ‘ƒ3
ğ‘ƒ4
ğ‘ƒ1
00000000
11111111
00001111
11000011
ğ‘ƒ2
11111111
00000000
11110000
00111100
ğ‘ƒ3
00001111
11110000
00000000
11001100
ğ‘ƒ4
11000011
00111100
11001100
00000000
So ğ¶1 and ğ¶2 are ğ‘ƒ2 and ğ‘ƒ3 in some order.
Notice that the attack is applicable because: (a) a stream cipher is employed; (b) the same secret
key and IV are used for generating the two ciphertexts.

## Page 2

CS2107
Tutorial 2
Question 2: Meet-in-the-middle
Instead of applying DES three times, Bob wants to apply it four times with 4 different
56-bit keys ğ‘˜1, ğ‘˜2, ğ‘˜3 and ğ‘˜4. By using meet-in-the-middle attack, what is the of number
of cryptographic operations (including encryption and decryption) required for known-
plaintext attack? Give your answer in the form of 2ğ‘˜and approximation (within a multi-
plicative factor of 2) is suffice. (Remark: Lecture note mentioned that there is a more efficient
meet-in-the-middle attack. Here, the simple meet-in-the-middle in the lecture note is suffice).
Answer
DES
DES
DES
DES
ğ‘˜1
ğ‘˜2
ğ‘˜3
ğ‘˜4
ğ‘
ğ‘
ğ‘
ğ‘
ğ‘¥0
ğ‘˜1 = 0
ğ‘¥1
ğ‘˜1 = 1
ğ‘¥2
ğ‘˜1 = 2
ğ‘¥3
ğ‘˜1 = 3
ğ‘¥0,0
ğ‘˜2 = 0 ğ‘¥0,1
ğ‘˜2 = 1
ğ‘¥0,2
ğ‘˜2 = 2
ğ‘¥0,3
ğ‘˜2 = 3
ğ‘¥3,0
ğ‘˜2 = 0
ğ‘¥3,1
ğ‘˜2 = 1
ğ‘¥3,2
ğ‘˜2 = 2
ğ‘¥3,3
ğ‘˜2 = 3
ğ‘¦0
ğ‘˜4 = 0
ğ‘¦1
ğ‘˜4 = 1
ğ‘¦2
ğ‘˜4 = 2
ğ‘¦3
ğ‘˜4 = 3
ğ‘¦0,0
ğ‘˜3 = 0
ğ‘¦1,0
ğ‘˜3 = 1
ğ‘¦2,0
ğ‘˜3 = 2
ğ‘¦3,0
ğ‘˜3 = 3
ğ‘¦0,3
ğ‘˜3 = 0
ğ‘¦1,3
ğ‘˜3 = 1
ğ‘¦2,3
ğ‘˜3 = 2
ğ‘¦3,3
ğ‘˜3 = 3
256
(256)
2
meet here
(256)
2
256
One can exhaustively enumerate ğ‘˜1, and for each ğ‘˜1, exhaustively search all ğ‘˜2. So, the num-
ber of encryptions will be (number of encryptions using ğ‘˜1) + (number of encryptions using
ğ‘˜2) = 256 + 2112 â‰ˆ2112. We need the same number of operations for ğ‘˜3 and ğ‘˜4. So total is
approximately 2112 Ã— 2 = 2113.
Demo
A running example of the attack using a tiny cipher:
https://gist.github.com/shnjmn/28b42c130eeb081ac1be78177ade6996#file-qn2-py
Remarks
â€¢ If applied 3 times, meet-in-the-middle needs approximately 2112 operations. So, increase
from 3 to 4 times only increase the â€œdifficultyâ€ from 2112 to 2113 (or â€œbit-strengthâ€ from 112
to 113).
â€¢ What about applying 2ğ‘¡âˆ’1 times vs applying it 2ğ‘¡times, when ğ‘¡= 3, 4, â€¦?
2ğ‘¡âˆ’1 times
â‹¯
256ğ‘¡operations
2ğ‘¡times
â‹¯
256ğ‘¡+1 operations
2

## Page 3

CS2107
Tutorial 2
Question 3
Alice sends instructions to Bob daily using mobile phone in the following way. Each in-
struction is represented as ASCII string, and follows the format:
action:date
The date is the 8-byte â€œdd/mm/yyâ€ format.
Actions are â€œbuyâ€, â€œsellâ€, â€œsell_everythingâ€, and â€œhold_and_seeâ€.
Example
buy:02/01/22
sell_everything:03/01/22
The message will be using AES under some mode-of-operation. The ciphertext, which is
a binary string, is then converted to a text message using some tools, e.g. uuencode. The
text message is then sent to Bob using SMS.
The mobile phone, after each re-start, will set the IV to be the string of all zeros, and then
increases it by one (i.e. treat it as binary number and increment by 1, similar to the CTR
mode) for every new encryption. An attacker is able to sniff the SMS channel between
Alice and Bob.
Let us consider two settings:
(a) Suppose the mode-of-operation is CBC mode. What information regarding the plain-
text can be inferred by the attacker? Note that under CBC mode, message padding
is required if the message length is not multiples of 16-byte. In this question, the
padding is simply done by appending bytes of zeros at the end of the message string.
(b) Suppose the mode-of-operation is CTR mode. What information regarding the plain-
text can be inferred by the attacker?
(Remark: The question doesnâ€™t state precisely what type of info can be sniffed from the communication
channel. From the context, it should be clear that the sniffed data are IV and the ciphertext. )
Demo
Messages and ciphertexts used for demonstration are generated using the following
script:
https://gist.github.com/shnjmn/28b42c130eeb081ac1be78177ade6996#file-qn3-py
Answer
The block size for AES is 16 bytes. The message (in plaintext) length can be inferred
from the action and date format.
â€¢ buy:dd/mm/yy (12 bytes)
â€¢ sell:dd/mm/yy (13 bytes)
â€¢ sell_everything:dd/mm/yy (24 bytes)
â€¢ hold_and_see:dd/mm/yy (21 bytes)
(a) (Ciphertext length) â€œbuyâ€ and â€œsellâ€ instructions after padding will take 1 blocks; while
â€œsell_everythingâ€ and â€œhold_and_seeâ€ instructions will take 2 blocks. Simply from
the length of the ciphertext, the attacker can tell whether the action is in {sell, buy} or
3

## Page 4

CS2107
Tutorial 2
in {sell_everything, hold_and_see}
IV
Ciphertext
Action Inferred
0
63bc7932...2935655a
{sell, buy}
0
4016231f...c8a3f888
{sell, buy}
1
2f8f9261...922bc452 : e2618598...ebcb1f86
{sell_everything, hold_and_see}
0
717554c9...7b163ad8 : 5f7c9a17...fefc8815
{sell_everything, hold_and_see}
(IV reuse) Due to the re-start and the way IV is generated, attacker can get a few cipher-
texts with the same IV. (Note that IV is sent in clear.) The attacker may collect multiple
pairs of IV and ciphertext. Among those 2-block ciphertexts, i.e. (ğ‘£, ğ‘1, ğ‘2), having the
same IV ğ‘£, the attacker can count how many of them have the same ğ‘1. If there are mul-
tiple ciphertexts with the same ğ‘1, the attacker can infer that their plaintext also share the
same 16-byte prefix, which must be â€œsell_everything:â€. And those having different ğ‘1
must correspond to â€œhold_and_see:dd/â€.
IV
Ciphertext
Action Inferred
1
458b5e24ce...1a6707db6b : 728e212e43...b8886b6962
hold_and_see
1
2f8f92614b...a9922bc452 : d4ce148bff...7b3f792677
sell_everything
1
2f8f92614b...a9922bc452 : 4f7e533a15...279d87bded
sell_everything
1
2f8f92614b...a9922bc452 : 4f3c4d30b2...e41925924a
sell_everything
2
b4d1ee5b1e...dc67169b13 : c3c4409f4a...c779cd9a52
hold_and_see
2
4a389fd40f...a402686a4d : ea6c970fc2...6b97a28f77
hold_and_see
2
12b9ddb33a...35d40817ef : 2490a4cd3a...680f69e8d9
hold_and_see
2
6ee87ea934...70173ff15d : f8dd64ccdd...9689c4476d
hold_and_see
2
0bf7555715...956da692a7 : ce9675758d...a876684d0b
hold_and_see
2
bd0ee3cbd6...e34c357ba7 : 2dc84a3e30...294846fc04
sell_everything
2
bd0ee3cbd6...e34c357ba7 : cc16fc3a03...9b975d6c12
sell_everything
2
bd0ee3cbd6...e34c357ba7 : db3188cbcd...3b0b3a0a68
sell_everything
3
e2197deccd...10576b3800 : 18273a6710...1385ebc6cf
hold_and_see
3
ee12b819f8...9584a0183a : 076c93674b...3b67f90fac
sell_everything
The above works because, due to same IV, the ciphertext is the same iff the plaintext is the
same. â€œsell_everything:â€ is 16 bytes and fit into a block, and it appears as first block in
the plaintext. By CBC, this 1st block of plaintext will be encrypted to the same ciphertext.
On the contrary, â€œhold_and_see:â€ is less than 16 bytes and will be followed by the â€œdayâ€
that likely to be different. So the ciphertext likely to be different.
There could be some cases that Alice sent multiple â€œhold_and_seeâ€ messages with the
same â€œdayâ€. Due to the same â€œdayâ€ in the date, the first block of â€œhold_and_see:dd/â€ are
the same for two different captures. In such cases, attacker would observe two groups of
ciphertexts having the same first block. Likely that the larger one is â€œsell_everything:â€.
Remark:
â€¢ Note that the 3rd block of ciphertext would be different.
â€¢ Unfortunately, the above canâ€™t apply to â€œbuyâ€ and â€œsellâ€.
â€¢ Whether attacker know the date or not would not affect the outcome.
4

## Page 5

CS2107
Tutorial 2
(b) (Ciphertext length) CTR mode keeps the length of plaintext and ciphertext the same. So,
the attacker can immediately know the exact action being performed based on the cipher-
text length.
IV
Ciphertext
Action Inferred
0
2b8790a2c04e014e0647326591
sell
0
3a9785f4ca4d1f510e502f62
buy
1
70edb6a23fd3d5f78151b6d118dc9942 c7a4859b71646b16
sell_everything
0
308d90aaa51f5e05690c78329ed77175 33b0f5fc55
hold_and_see
(IV reuse) If two messages are encrypted with the same IV, the XOR of ciphertexts will
reveal the XOR of the corresponding plaintexts.
For example, given two ciphertexts:
IV
Ciphertext
ğ‘š1
3
4277681b7e40bbea18a68499
ğ‘š2
3
53677d4d1116e2bf52f0c2c4b9fdccda f8798d2929a11b48
Observing the lengths of the ciphertexts, we see that ğ‘š1 has 12 bytes of ciphertext, and ğ‘š2
has 24 bytes of ciphertext. Thus, ğ‘š1 is a â€œbuyâ€ instruction, and ğ‘š2 is a â€œsell_everythingâ€
instruction. Therefore, we know that the first 12 bytes of ğ‘š2 are â€œsell_everythâ€.
Since the two ciphertexts are encrypted with the same IV, we have ğ‘š1 âŠ•ğ‘š2 = ğ‘1 âŠ•ğ‘2.1
ğ‘š1 âŠ•"sell_everyth" = 4277681b7e40bbea18a68499 âŠ•53677d4d1116e2bf52f0c2c4
= 111015566f5659554a56465d
ğ‘š1 = 111015566f5659554a56465d âŠ•"sell_everyth"
= 111015566f5659554a56465d âŠ•73656c6c5f65766572797468
= 6275793a30332f30382f3235 = "buy:03/08/25"
(Counter overlap) Suppose two instructions are consecutively encrypted, and the first
ciphertext consists of 3 blocks (including the IV). Let the first ciphertext be (ğ‘£, ğ‘1, ğ‘2) and
the corresponding plaintext is ğ‘1â€–ğ‘2. Let the third ciphertext be (ğ‘£+ 1, ğ‘3) or (ğ‘£+ 1, ğ‘3, ğ‘4)
depending its size, and the corresponding plaintext of ğ‘3 is ğ‘3.
AESğ‘˜
AESğ‘˜
AESğ‘˜
ğ‘£+ 1
ğ‘£+ 2
ğ‘£+ 2
IV = ğ‘£
IV = ğ‘£+ 1
âŠ•
ğ‘1
ğ‘1
âŠ•
ğ‘2
ğ‘2
âŠ•
ğ‘3
ğ‘3
1In this case, when XORing two bit-strings of different lengths, we truncate the longer one to the length of the
shorter one.
5

## Page 6

CS2107
Tutorial 2
Note that by CTR mode, ğ‘2 = ğ‘2 âŠ•AES(ğ‘£+ 2), and ğ‘3 = ğ‘3 âŠ•AES(ğ‘£+ 2). That is, the
counter is the same. So, similar to the â€œzebraâ€ example in lecture note, the attacker can
obtain ğ‘2 âŠ•ğ‘3 = ğ‘2 âŠ•ğ‘3.
For example, consider the following tiny capture:
IV
Ciphertext
ğ‘š3
0
2b8790a2a51b46044406693fcd892260 33baf5fe589991a7
ğ‘š4
1
6be7b6aa3fd7cdf6ac5ba7dc4b82c657 c7ad85997c
Observing the lengths of the ciphertexts, we see that ğ‘š3 has 24 bytes of ciphertext, and
ğ‘š4 has 21 bytes of ciphertext. Thus, ğ‘š3 is a â€œsell_everythingâ€ instruction, and ğ‘š4 is a
â€œhold_and_seeâ€ instruction. That is
â€¢ ğ‘š3 is "sell_everything:aa/bb/cc";
â€¢ ğ‘š4 is "hold_and_see:xx/yy/zz".
From how CTR mode works, we know for ğ‘š3:
AESğ‘˜(1) âŠ•"sell_everything:"
=
2b8790a2a51b46044406693fcd892260
AESğ‘˜(2) âŠ•"aa/bb/cc"
=
33baf5fe589991a7
(1)
And for ğ‘š4:
AESğ‘˜(2) âŠ•"hold_and_see:xx/"
=
6be7b6aa3fd7cdf6ac5ba7dc4b82c657
(2)
AESğ‘˜(3) âŠ•"yy/zz"
=
c7ad85997c
By XORing (1) and (2), we obtain:
"hold_and" âŠ•"aa/bb/cc" = 6be7b6aa3fd7cdf6 âŠ•33baf5fe589991a7
= 585d4354674e5c51
"aa/bb/cc" = 585d4354674e5c51 âŠ•"hold_and"
= 585d4354674e5c51 âŠ•686f6c645f616e64
= 30322f30382f3235 = "02/08/25"
In that way, we can recover the plaintext of ğ‘š3, which is "sell_everything:02/08/25".
6

## Page 7

CS2107
Tutorial 2
Question 4: (Padding Oracle)
Consider the padding oracle attack described in the lecture note. Suppose the attacker
knows that the 16-byte plaintext is the sequence
âŸ¨ğ‘1, ğ‘2, ğ‘3, ğ‘4, ğ‘5, ğ‘6, ğ‘7, ğ‘8, ğ‘9, 00, 00, FF, 04, 04, 04, 04âŸ©,
where the numbers are in hexadecimal representation, and the attacker does not know
the value of the ğ‘ğ‘–â€™s. Describe how the attacker determine the value of ğ‘9. In particular,
describe how to decide the value of ğ‘£in the lecture note.
Answer
To launch padding oracle attack, the attacker knows a pair of valid IV ğ‘£and cipher-
text ğ‘. Since the question also assumes that the attacker knows part of the plaintext, we know
ğ‘£âŠ•AESâˆ’1
ğ‘˜(ğ‘) = âŸ¨ğ‘1, ğ‘2, ğ‘3, ğ‘4, ğ‘5, ğ‘6, ğ‘7, ğ‘8, ğ‘9, 00, 00, FF, 04, 04, 04, 04âŸ©.
There are 8 bytes from ğ‘9 to the end of the block. To find ğ‘9, the attacker need to manipulate
the IV so that the decryption of the block has a valid padding of 8 bytes. That is, we need to
find a ğ‘£â€² such that
ğ‘£â€² âŠ•AESâˆ’1
ğ‘˜(ğ‘) = âŸ¨ğ‘1, ğ‘2, ğ‘3, ğ‘4, ğ‘5, ğ‘6, ğ‘7, ğ‘8, 08, 08, 08, 08, 08, 08, 08, 08âŸ©.
XOR the two equations, we have
ğ‘£â€² âŠ•ğ‘£= âŸ¨00, 00, 00, 00, 00, 00, 00, 00, ğ‘¡, 08, 08, F7, 0C, 0C, 0C, 0CâŸ©,
where ğ‘¡= ğ‘9 âŠ•08 is the only unknown.
Thus we can find ğ‘¡by brute-forcing all possible values.
1: for ğ‘¡= 0 to FF do
2:
let ğ‘£= ğ¼ğ‘‰âŠ•âŸ¨0, 0, 0, 0, 0, 0, 0, 0, ğ‘¡, 08, 08, F7, 0C, 0C, 0C, 0CâŸ©.
3:
send ğ‘£â€–ğ‘to oracle.
4:
if yes then
5:
return ğ‘¡âŠ•08.
6:
end if
7: end for
7

## Page 8

CS2107
Tutorial 2
Question 5
The lecture notes assume the attacker knows the number of padding bytes. Now, consider
a scenario where this information is unknown. Suppose the attacker has access to the
one-block IV and a two-block ciphertext, but does not know how many padding bytes are
present. Describe a method the attacker can use to determine the number of padding
bytes, using as few oracle queries as possible.
Answer
Unlike the lecture note, here, we assume the ciphertext (including the IV) is three
blocks.
Let the IV and ciphertext be denoted as ğ‘£and ğ‘1â€–ğ‘2, respectively. To find about ğ‘2, the attacker
should modify ğ‘1 and query the oracle (instead of modifying the IV).
Padding
Unknown Values
Y
X
ğ‘2
AESâˆ’1
ğ‘˜(ğ‘2)
ğ‘1
=
âŠ•
Imagine flipping a byte in ğ‘1. If the flipped byte lies in region X, the modification will not
affect the padding, and the oracle will return â€œvalid.â€ If the flipped byte lies in region Y, the
modification will alter a padding byte, and the oracle will return â€œinvalid.â€ The core idea is
therefore to identify the boundary between valid and invalid responses.
Method 1: Assume that the length is ğ‘–, and test it. Test one by one starting from 1, â€¦ , 16.
1: for ğ‘–= 1 to 16 do
2:
ğ‘1[ğ‘–] â†ğ‘1[ğ‘–] âŠ•FF.
3:
send ğ‘1â€–ğ‘2 to oracle.
4:
if no then
5:
return 17 âˆ’ğ‘–
6:
end if
7: end for
Method 2: Improved version. Use binary search to find the ğ‘–that goes from valid to invalid.
(Optional remark: canâ€™t do better than binary search. There are 16 possible outcomes, and
every query would eliminate at most halve.)
8

## Page 9

CS2107
Tutorial 2
Question 6: Padding oracle attack is practical
Search the CVE database for a known vulnerability that is based on AES-CBC padding
oracle attack. (Note: there are also padding oracle attack on other encryption scheme).
Answer
There are many. E.g. CVE-2023-2197.
HashiCorp Vault Enterprise 1.13.0 up to 1.13.1 is vulnerable to a padding oracle at-
tackwhenusinganHSMinconjunctionwiththeCKM_AES_CBC_PADorCKM_AES_CBC
encryption mechanisms. An attacker with privileges to modify storage and restart
Vault may be able to intercept or modify cipher text in order to derive Vaultâ€™s root
key. Fixed in 1.13.2
9