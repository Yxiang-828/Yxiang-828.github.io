# CS2107 Assignment 1 - Med4 Solution (Detailed)

## Problem
"M.4 Spill Some Tea" - Interact with a server using ChaCha20-Poly1305 encryption, but the nonce is reused.

## Analysis
The server uses ChaCha20Poly1305 for encryption, but the nonce is generated once and reused for all encryptions. This is insecure because ChaCha20 requires unique nonces per encryption with the same key.

Reusing the nonce means the keystream is identical for all encryptions, allowing for stream cipher attacks.

ChaCha20-Poly1305 is an AEAD cipher: it provides confidentiality (via ChaCha20 stream cipher) and authenticity (via Poly1305 MAC).

- **Keystream**: Generated by ChaCha20 from key, nonce, and counter. XORed with plaintext to produce ciphertext.
- **Authentication Tag**: 16-byte MAC computed over the ciphertext and additional data (none here).
- **Encrypted Message Format**: ciphertext + 16-byte tag.

Since nonce is reused, keystream is the same for all messages.

## Exploit Procedure (Step-by-Step)

### 1. Connect to Server
Run: `nc cs2107-ctfd-i.comp.nus.edu.sg 5003`

Server menu:
```
===============================================================
            ChaCha20-Poly1305 Secure Tea Spilling Service
===============================================================
We use state-of-the-art ChaCha20-Poly1305 encryption!

Menu:
1. Encrypt Tea
2. Get Encrypted Flag
3. About Our Security
4. Exit
```

### 2. Get Encrypted Flag
Send: `2`

Server responds:
```
Encrypted Flag (hex): <encrypted_flag_hex>
Length: <length> bytes
Hint: The flag follows the standard CS2107{...} format
```

- `<encrypted_flag_hex>`: Hex string of the encrypted flag (ciphertext + 16-byte tag).
- `<length>`: Total length in bytes of `<encrypted_flag_hex>` (e.g., 76).
- This is the full encrypted message: `ciphertext_flag + tag_flag`.
- **What is trimmed later**: The last 16 bytes (tag) are removed before XOR to get `ciphertext_flag`.

### 3. Encrypt Known Plaintext
Send: `1`

Server prompts: `Enter your Tea: `

Send: `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA` (60 'A's)

Server responds:
```
Encrypted Tea (hex): <encrypted_known_hex>
Length: 76 bytes
```

- `<encrypted_known_hex>`: Hex string of the encrypted known plaintext (ciphertext + 16-byte tag).
- Length is always 76 bytes (60 bytes plaintext + 16 bytes tag).
- This is the full encrypted message: `ciphertext_known + tag_known`.
- **What is trimmed later**: The last 16 bytes (tag) are removed before XOR to get `ciphertext_known`.

### 4. Recover Keystream
- Known plaintext: `b'A' * 60` (60 bytes of 0x41).
- Encrypted known: `bytes.fromhex(<encrypted_known_hex>)` (76 bytes total).
- **Trim tag**: `encrypted_known[:-16]` (removes last 16 bytes, leaves 60 bytes: `ciphertext_known`).
- **XOR for keystream**: `keystream = known XOR encrypted_known[:-16]` (60 bytes).
  - This gives the ChaCha20 keystream used for encryption.
  - Code: `keystream = bytes(a ^ b for a, b in zip(known, encrypted_known[:-16]))`

### 5. Decrypt Flag
- Encrypted flag: `bytes.fromhex(<encrypted_flag_hex>)` (76 bytes total).
- **Trim tag**: `encrypted_flag[:-16]` (removes last 16 bytes, leaves 60 bytes: `ciphertext_flag`).
- **XOR for plaintext**: `flag_bytes = encrypted_flag[:-16] XOR keystream` (60 bytes).
  - Code: `flag_bytes = bytes(a ^ b for a, b in zip(encrypted_flag[:-16], keystream))`
- Decode: `flag = flag_bytes.decode('utf-8')` (since it's valid UTF-8).

### Why Trim the Tag?
- The tag is for authentication, not part of the ciphertext.
- ChaCha20 only encrypts the plaintext to ciphertext; the tag is separate.
- XOR only applies to the ciphertext part to recover plaintext.
- Trimming ensures we only XOR the encrypted data, not the MAC.

### Full Code Breakdown (from exploit.py)
```python
# Get encrypted flag
send(sock, "2")
data = recv_until(sock, ">> ")
encrypted_flag_hex = extract from data
length = extract from data  # e.g., 76

# Send known plaintext
flag_len = length - 16  # 60
known = b"A" * flag_len  # b'A' * 60
send(sock, "1")
recv_until(sock, "Enter your Tea: ")
send(sock, known.decode())  # Sends "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"

# Get encrypted known
data = recv_until(sock, ">> ")
encrypted_known_hex = extract from data

# Compute keystream
encrypted_flag = bytes.fromhex(encrypted_flag_hex)  # 76 bytes
encrypted_known = bytes.fromhex(encrypted_known_hex)  # 76 bytes
keystream = bytes(a ^ b for a, b in zip(known, encrypted_known[:-16]))  # known (60) XOR encrypted_known[:-16] (60) = keystream (60)

# Decrypt flag
flag_bytes = bytes(a ^ b for a, b in zip(encrypted_flag[:-16], keystream))  # encrypted_flag[:-16] (60) XOR keystream (60) = flag_bytes (60)
flag = flag_bytes.decode()  # "CS2107{t3a_w4s_sP1lled_chacha20_n0nc3_r3us3_1s_d4ng3r0us!!!}"
```

## Flag
CS2107{t3a_w4s_sP1lled_chacha20_n0nc3_r3us3_1s_d4ng3r0us!!!}

## Notes
- ChaCha20-Poly1305 is AEAD; reusing nonce breaks confidentiality.
- The hint confirms "the nonce is reused!"
- Trimming is crucial: always remove the 16-byte tag before XOR.
- The flag is 60 bytes, matching the known plaintext length.