# CS2107 — Introduction to Information Security

## Page 1

CS2107 — Introduction to Information Security
AY2025/2026 Semester 1
Tutorial 2
Shen Jiamin
Question 1
You have intercepted two ciphertexts 𝐶1, 𝐶2 generated by a stream cipher using the same
secret key. The first 4 bits of the ciphertext form the IV.
𝐶1 = 0111 11011011
𝐶2 = 0111 00101011
You know that the plaintext must be among the following 4 sequences:
𝑃1 = 00000000, 𝑃2 = 11111111, 𝑃3 = 00001111, 𝑃4 = 11000011
What are the possible plaintexts of 𝐶1 and 𝐶2?
Answer
The important observation here is that the same IV is used for both ciphertexts,
which allows us to exploit the properties of the XOR operation.
Stream ciphers encrypt plaintext by XORing it with a keystream generated from the secret key
and IV, i.e.
𝐶= 𝑃⊕PRG(𝐾, 𝐼𝑉).
Since the same IV is used, the keystream for both ciphertexts is identical. Thus
𝐶1 ⊕𝐶2 = (𝑃1 ⊕PRG(𝐾, 𝐼𝑉)) ⊕(𝑃2 ⊕PRG(𝐾, 𝐼𝑉)) = 𝑃1 ⊕𝑃2 = 11110000.
𝐶1 ⊕𝐶1 = 11110000.
⊕
𝑃1
𝑃2
𝑃3
𝑃4
𝑃1
00000000
11111111
00001111
11000011
𝑃2
11111111
00000000
11110000
00111100
𝑃3
00001111
11110000
00000000
11001100
𝑃4
11000011
00111100
11001100
00000000
So 𝐶1 and 𝐶2 are 𝑃2 and 𝑃3 in some order.
Notice that the attack is applicable because: (a) a stream cipher is employed; (b) the same secret
key and IV are used for generating the two ciphertexts.

## Page 2

CS2107
Tutorial 2
Question 2: Meet-in-the-middle
Instead of applying DES three times, Bob wants to apply it four times with 4 different
56-bit keys 𝑘1, 𝑘2, 𝑘3 and 𝑘4. By using meet-in-the-middle attack, what is the of number
of cryptographic operations (including encryption and decryption) required for known-
plaintext attack? Give your answer in the form of 2𝑘and approximation (within a multi-
plicative factor of 2) is suffice. (Remark: Lecture note mentioned that there is a more efficient
meet-in-the-middle attack. Here, the simple meet-in-the-middle in the lecture note is suffice).
Answer
DES
DES
DES
DES
𝑘1
𝑘2
𝑘3
𝑘4
𝑝
𝑐
𝑝
𝑐
𝑥0
𝑘1 = 0
𝑥1
𝑘1 = 1
𝑥2
𝑘1 = 2
𝑥3
𝑘1 = 3
𝑥0,0
𝑘2 = 0 𝑥0,1
𝑘2 = 1
𝑥0,2
𝑘2 = 2
𝑥0,3
𝑘2 = 3
𝑥3,0
𝑘2 = 0
𝑥3,1
𝑘2 = 1
𝑥3,2
𝑘2 = 2
𝑥3,3
𝑘2 = 3
𝑦0
𝑘4 = 0
𝑦1
𝑘4 = 1
𝑦2
𝑘4 = 2
𝑦3
𝑘4 = 3
𝑦0,0
𝑘3 = 0
𝑦1,0
𝑘3 = 1
𝑦2,0
𝑘3 = 2
𝑦3,0
𝑘3 = 3
𝑦0,3
𝑘3 = 0
𝑦1,3
𝑘3 = 1
𝑦2,3
𝑘3 = 2
𝑦3,3
𝑘3 = 3
256
(256)
2
meet here
(256)
2
256
One can exhaustively enumerate 𝑘1, and for each 𝑘1, exhaustively search all 𝑘2. So, the num-
ber of encryptions will be (number of encryptions using 𝑘1) + (number of encryptions using
𝑘2) = 256 + 2112 ≈2112. We need the same number of operations for 𝑘3 and 𝑘4. So total is
approximately 2112 × 2 = 2113.
Demo
A running example of the attack using a tiny cipher:
https://gist.github.com/shnjmn/28b42c130eeb081ac1be78177ade6996#file-qn2-py
Remarks
• If applied 3 times, meet-in-the-middle needs approximately 2112 operations. So, increase
from 3 to 4 times only increase the “difficulty” from 2112 to 2113 (or “bit-strength” from 112
to 113).
• What about applying 2𝑡−1 times vs applying it 2𝑡times, when 𝑡= 3, 4, …?
2𝑡−1 times
⋯
256𝑡operations
2𝑡times
⋯
256𝑡+1 operations
2

## Page 3

CS2107
Tutorial 2
Question 3
Alice sends instructions to Bob daily using mobile phone in the following way. Each in-
struction is represented as ASCII string, and follows the format:
action:date
The date is the 8-byte “dd/mm/yy” format.
Actions are “buy”, “sell”, “sell_everything”, and “hold_and_see”.
Example
buy:02/01/22
sell_everything:03/01/22
The message will be using AES under some mode-of-operation. The ciphertext, which is
a binary string, is then converted to a text message using some tools, e.g. uuencode. The
text message is then sent to Bob using SMS.
The mobile phone, after each re-start, will set the IV to be the string of all zeros, and then
increases it by one (i.e. treat it as binary number and increment by 1, similar to the CTR
mode) for every new encryption. An attacker is able to sniff the SMS channel between
Alice and Bob.
Let us consider two settings:
(a) Suppose the mode-of-operation is CBC mode. What information regarding the plain-
text can be inferred by the attacker? Note that under CBC mode, message padding
is required if the message length is not multiples of 16-byte. In this question, the
padding is simply done by appending bytes of zeros at the end of the message string.
(b) Suppose the mode-of-operation is CTR mode. What information regarding the plain-
text can be inferred by the attacker?
(Remark: The question doesn’t state precisely what type of info can be sniffed from the communication
channel. From the context, it should be clear that the sniffed data are IV and the ciphertext. )
Demo
Messages and ciphertexts used for demonstration are generated using the following
script:
https://gist.github.com/shnjmn/28b42c130eeb081ac1be78177ade6996#file-qn3-py
Answer
The block size for AES is 16 bytes. The message (in plaintext) length can be inferred
from the action and date format.
• buy:dd/mm/yy (12 bytes)
• sell:dd/mm/yy (13 bytes)
• sell_everything:dd/mm/yy (24 bytes)
• hold_and_see:dd/mm/yy (21 bytes)
(a) (Ciphertext length) “buy” and “sell” instructions after padding will take 1 blocks; while
“sell_everything” and “hold_and_see” instructions will take 2 blocks. Simply from
the length of the ciphertext, the attacker can tell whether the action is in {sell, buy} or
3

## Page 4

CS2107
Tutorial 2
in {sell_everything, hold_and_see}
IV
Ciphertext
Action Inferred
0
63bc7932...2935655a
{sell, buy}
0
4016231f...c8a3f888
{sell, buy}
1
2f8f9261...922bc452 : e2618598...ebcb1f86
{sell_everything, hold_and_see}
0
717554c9...7b163ad8 : 5f7c9a17...fefc8815
{sell_everything, hold_and_see}
(IV reuse) Due to the re-start and the way IV is generated, attacker can get a few cipher-
texts with the same IV. (Note that IV is sent in clear.) The attacker may collect multiple
pairs of IV and ciphertext. Among those 2-block ciphertexts, i.e. (𝑣, 𝑐1, 𝑐2), having the
same IV 𝑣, the attacker can count how many of them have the same 𝑐1. If there are mul-
tiple ciphertexts with the same 𝑐1, the attacker can infer that their plaintext also share the
same 16-byte prefix, which must be “sell_everything:”. And those having different 𝑐1
must correspond to “hold_and_see:dd/”.
IV
Ciphertext
Action Inferred
1
458b5e24ce...1a6707db6b : 728e212e43...b8886b6962
hold_and_see
1
2f8f92614b...a9922bc452 : d4ce148bff...7b3f792677
sell_everything
1
2f8f92614b...a9922bc452 : 4f7e533a15...279d87bded
sell_everything
1
2f8f92614b...a9922bc452 : 4f3c4d30b2...e41925924a
sell_everything
2
b4d1ee5b1e...dc67169b13 : c3c4409f4a...c779cd9a52
hold_and_see
2
4a389fd40f...a402686a4d : ea6c970fc2...6b97a28f77
hold_and_see
2
12b9ddb33a...35d40817ef : 2490a4cd3a...680f69e8d9
hold_and_see
2
6ee87ea934...70173ff15d : f8dd64ccdd...9689c4476d
hold_and_see
2
0bf7555715...956da692a7 : ce9675758d...a876684d0b
hold_and_see
2
bd0ee3cbd6...e34c357ba7 : 2dc84a3e30...294846fc04
sell_everything
2
bd0ee3cbd6...e34c357ba7 : cc16fc3a03...9b975d6c12
sell_everything
2
bd0ee3cbd6...e34c357ba7 : db3188cbcd...3b0b3a0a68
sell_everything
3
e2197deccd...10576b3800 : 18273a6710...1385ebc6cf
hold_and_see
3
ee12b819f8...9584a0183a : 076c93674b...3b67f90fac
sell_everything
The above works because, due to same IV, the ciphertext is the same iff the plaintext is the
same. “sell_everything:” is 16 bytes and fit into a block, and it appears as first block in
the plaintext. By CBC, this 1st block of plaintext will be encrypted to the same ciphertext.
On the contrary, “hold_and_see:” is less than 16 bytes and will be followed by the “day”
that likely to be different. So the ciphertext likely to be different.
There could be some cases that Alice sent multiple “hold_and_see” messages with the
same “day”. Due to the same “day” in the date, the first block of “hold_and_see:dd/” are
the same for two different captures. In such cases, attacker would observe two groups of
ciphertexts having the same first block. Likely that the larger one is “sell_everything:”.
Remark:
• Note that the 3rd block of ciphertext would be different.
• Unfortunately, the above can’t apply to “buy” and “sell”.
• Whether attacker know the date or not would not affect the outcome.
4

## Page 5

CS2107
Tutorial 2
(b) (Ciphertext length) CTR mode keeps the length of plaintext and ciphertext the same. So,
the attacker can immediately know the exact action being performed based on the cipher-
text length.
IV
Ciphertext
Action Inferred
0
2b8790a2c04e014e0647326591
sell
0
3a9785f4ca4d1f510e502f62
buy
1
70edb6a23fd3d5f78151b6d118dc9942 c7a4859b71646b16
sell_everything
0
308d90aaa51f5e05690c78329ed77175 33b0f5fc55
hold_and_see
(IV reuse) If two messages are encrypted with the same IV, the XOR of ciphertexts will
reveal the XOR of the corresponding plaintexts.
For example, given two ciphertexts:
IV
Ciphertext
𝑚1
3
4277681b7e40bbea18a68499
𝑚2
3
53677d4d1116e2bf52f0c2c4b9fdccda f8798d2929a11b48
Observing the lengths of the ciphertexts, we see that 𝑚1 has 12 bytes of ciphertext, and 𝑚2
has 24 bytes of ciphertext. Thus, 𝑚1 is a “buy” instruction, and 𝑚2 is a “sell_everything”
instruction. Therefore, we know that the first 12 bytes of 𝑚2 are “sell_everyth”.
Since the two ciphertexts are encrypted with the same IV, we have 𝑚1 ⊕𝑚2 = 𝑐1 ⊕𝑐2.1
𝑚1 ⊕"sell_everyth" = 4277681b7e40bbea18a68499 ⊕53677d4d1116e2bf52f0c2c4
= 111015566f5659554a56465d
𝑚1 = 111015566f5659554a56465d ⊕"sell_everyth"
= 111015566f5659554a56465d ⊕73656c6c5f65766572797468
= 6275793a30332f30382f3235 = "buy:03/08/25"
(Counter overlap) Suppose two instructions are consecutively encrypted, and the first
ciphertext consists of 3 blocks (including the IV). Let the first ciphertext be (𝑣, 𝑐1, 𝑐2) and
the corresponding plaintext is 𝑝1‖𝑝2. Let the third ciphertext be (𝑣+ 1, 𝑐3) or (𝑣+ 1, 𝑐3, 𝑐4)
depending its size, and the corresponding plaintext of 𝑐3 is 𝑝3.
AES𝑘
AES𝑘
AES𝑘
𝑣+ 1
𝑣+ 2
𝑣+ 2
IV = 𝑣
IV = 𝑣+ 1
⊕
𝑝1
𝑐1
⊕
𝑝2
𝑐2
⊕
𝑝3
𝑐3
1In this case, when XORing two bit-strings of different lengths, we truncate the longer one to the length of the
shorter one.
5

## Page 6

CS2107
Tutorial 2
Note that by CTR mode, 𝑐2 = 𝑝2 ⊕AES(𝑣+ 2), and 𝑐3 = 𝑝3 ⊕AES(𝑣+ 2). That is, the
counter is the same. So, similar to the “zebra” example in lecture note, the attacker can
obtain 𝑝2 ⊕𝑝3 = 𝑐2 ⊕𝑐3.
For example, consider the following tiny capture:
IV
Ciphertext
𝑚3
0
2b8790a2a51b46044406693fcd892260 33baf5fe589991a7
𝑚4
1
6be7b6aa3fd7cdf6ac5ba7dc4b82c657 c7ad85997c
Observing the lengths of the ciphertexts, we see that 𝑚3 has 24 bytes of ciphertext, and
𝑚4 has 21 bytes of ciphertext. Thus, 𝑚3 is a “sell_everything” instruction, and 𝑚4 is a
“hold_and_see” instruction. That is
• 𝑚3 is "sell_everything:aa/bb/cc";
• 𝑚4 is "hold_and_see:xx/yy/zz".
From how CTR mode works, we know for 𝑚3:
AES𝑘(1) ⊕"sell_everything:"
=
2b8790a2a51b46044406693fcd892260
AES𝑘(2) ⊕"aa/bb/cc"
=
33baf5fe589991a7
(1)
And for 𝑚4:
AES𝑘(2) ⊕"hold_and_see:xx/"
=
6be7b6aa3fd7cdf6ac5ba7dc4b82c657
(2)
AES𝑘(3) ⊕"yy/zz"
=
c7ad85997c
By XORing (1) and (2), we obtain:
"hold_and" ⊕"aa/bb/cc" = 6be7b6aa3fd7cdf6 ⊕33baf5fe589991a7
= 585d4354674e5c51
"aa/bb/cc" = 585d4354674e5c51 ⊕"hold_and"
= 585d4354674e5c51 ⊕686f6c645f616e64
= 30322f30382f3235 = "02/08/25"
In that way, we can recover the plaintext of 𝑚3, which is "sell_everything:02/08/25".
6

## Page 7

CS2107
Tutorial 2
Question 4: (Padding Oracle)
Consider the padding oracle attack described in the lecture note. Suppose the attacker
knows that the 16-byte plaintext is the sequence
⟨𝑏1, 𝑏2, 𝑏3, 𝑏4, 𝑏5, 𝑏6, 𝑏7, 𝑏8, 𝑏9, 00, 00, FF, 04, 04, 04, 04⟩,
where the numbers are in hexadecimal representation, and the attacker does not know
the value of the 𝑏𝑖’s. Describe how the attacker determine the value of 𝑏9. In particular,
describe how to decide the value of 𝑣in the lecture note.
Answer
To launch padding oracle attack, the attacker knows a pair of valid IV 𝑣and cipher-
text 𝑐. Since the question also assumes that the attacker knows part of the plaintext, we know
𝑣⊕AES−1
𝑘(𝑐) = ⟨𝑏1, 𝑏2, 𝑏3, 𝑏4, 𝑏5, 𝑏6, 𝑏7, 𝑏8, 𝑏9, 00, 00, FF, 04, 04, 04, 04⟩.
There are 8 bytes from 𝑏9 to the end of the block. To find 𝑏9, the attacker need to manipulate
the IV so that the decryption of the block has a valid padding of 8 bytes. That is, we need to
find a 𝑣′ such that
𝑣′ ⊕AES−1
𝑘(𝑐) = ⟨𝑏1, 𝑏2, 𝑏3, 𝑏4, 𝑏5, 𝑏6, 𝑏7, 𝑏8, 08, 08, 08, 08, 08, 08, 08, 08⟩.
XOR the two equations, we have
𝑣′ ⊕𝑣= ⟨00, 00, 00, 00, 00, 00, 00, 00, 𝑡, 08, 08, F7, 0C, 0C, 0C, 0C⟩,
where 𝑡= 𝑏9 ⊕08 is the only unknown.
Thus we can find 𝑡by brute-forcing all possible values.
1: for 𝑡= 0 to FF do
2:
let 𝑣= 𝐼𝑉⊕⟨0, 0, 0, 0, 0, 0, 0, 0, 𝑡, 08, 08, F7, 0C, 0C, 0C, 0C⟩.
3:
send 𝑣‖𝑐to oracle.
4:
if yes then
5:
return 𝑡⊕08.
6:
end if
7: end for
7

## Page 8

CS2107
Tutorial 2
Question 5
The lecture notes assume the attacker knows the number of padding bytes. Now, consider
a scenario where this information is unknown. Suppose the attacker has access to the
one-block IV and a two-block ciphertext, but does not know how many padding bytes are
present. Describe a method the attacker can use to determine the number of padding
bytes, using as few oracle queries as possible.
Answer
Unlike the lecture note, here, we assume the ciphertext (including the IV) is three
blocks.
Let the IV and ciphertext be denoted as 𝑣and 𝑐1‖𝑐2, respectively. To find about 𝑐2, the attacker
should modify 𝑐1 and query the oracle (instead of modifying the IV).
Padding
Unknown Values
Y
X
𝑝2
AES−1
𝑘(𝑐2)
𝑐1
=
⊕
Imagine flipping a byte in 𝑐1. If the flipped byte lies in region X, the modification will not
affect the padding, and the oracle will return “valid.” If the flipped byte lies in region Y, the
modification will alter a padding byte, and the oracle will return “invalid.” The core idea is
therefore to identify the boundary between valid and invalid responses.
Method 1: Assume that the length is 𝑖, and test it. Test one by one starting from 1, … , 16.
1: for 𝑖= 1 to 16 do
2:
𝑐1[𝑖] ←𝑐1[𝑖] ⊕FF.
3:
send 𝑐1‖𝑐2 to oracle.
4:
if no then
5:
return 17 −𝑖
6:
end if
7: end for
Method 2: Improved version. Use binary search to find the 𝑖that goes from valid to invalid.
(Optional remark: can’t do better than binary search. There are 16 possible outcomes, and
every query would eliminate at most halve.)
8

## Page 9

CS2107
Tutorial 2
Question 6: Padding oracle attack is practical
Search the CVE database for a known vulnerability that is based on AES-CBC padding
oracle attack. (Note: there are also padding oracle attack on other encryption scheme).
Answer
There are many. E.g. CVE-2023-2197.
HashiCorp Vault Enterprise 1.13.0 up to 1.13.1 is vulnerable to a padding oracle at-
tackwhenusinganHSMinconjunctionwiththeCKM_AES_CBC_PADorCKM_AES_CBC
encryption mechanisms. An attacker with privileges to modify storage and restart
Vault may be able to intercept or modify cipher text in order to derive Vault’s root
key. Fixed in 1.13.2
9